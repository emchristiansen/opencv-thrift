{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Mat_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


data CVType = CV_8UC1|CV_8UC2|CV_8UC3|CV_8UC4|CV_8SC1|CV_8SC2|CV_8SC3|CV_8SC4|CV_16UC1|CV_16UC2|CV_16UC3|CV_16UC4|CV_16SC1|CV_16SC2|CV_16SC3|CV_16SC4|CV_32SC1|CV_32SC2|CV_32SC3|CV_32SC4|CV_32FC1|CV_32FC2|CV_32FC3|CV_32FC4|CV_64FC1|CV_64FC2|CV_64FC3|CV_64FC4  deriving (Show,Eq, Typeable, Ord)
instance Enum CVType where
  fromEnum t = case t of
    CV_8UC1 -> 0
    CV_8UC2 -> 1
    CV_8UC3 -> 2
    CV_8UC4 -> 3
    CV_8SC1 -> 4
    CV_8SC2 -> 5
    CV_8SC3 -> 6
    CV_8SC4 -> 7
    CV_16UC1 -> 8
    CV_16UC2 -> 9
    CV_16UC3 -> 10
    CV_16UC4 -> 11
    CV_16SC1 -> 12
    CV_16SC2 -> 13
    CV_16SC3 -> 14
    CV_16SC4 -> 15
    CV_32SC1 -> 16
    CV_32SC2 -> 17
    CV_32SC3 -> 18
    CV_32SC4 -> 19
    CV_32FC1 -> 20
    CV_32FC2 -> 21
    CV_32FC3 -> 22
    CV_32FC4 -> 23
    CV_64FC1 -> 24
    CV_64FC2 -> 25
    CV_64FC3 -> 26
    CV_64FC4 -> 27
  toEnum t = case t of
    0 -> CV_8UC1
    1 -> CV_8UC2
    2 -> CV_8UC3
    3 -> CV_8UC4
    4 -> CV_8SC1
    5 -> CV_8SC2
    6 -> CV_8SC3
    7 -> CV_8SC4
    8 -> CV_16UC1
    9 -> CV_16UC2
    10 -> CV_16UC3
    11 -> CV_16UC4
    12 -> CV_16SC1
    13 -> CV_16SC2
    14 -> CV_16SC3
    15 -> CV_16SC4
    16 -> CV_32SC1
    17 -> CV_32SC2
    18 -> CV_32SC3
    19 -> CV_32SC4
    20 -> CV_32FC1
    21 -> CV_32FC2
    22 -> CV_32FC3
    23 -> CV_32FC4
    24 -> CV_64FC1
    25 -> CV_64FC2
    26 -> CV_64FC3
    27 -> CV_64FC4
    _ -> throw ThriftException
instance Hashable CVType where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data Mat = Mat{f_Mat_rows :: Maybe Int64,f_Mat_cols :: Maybe Int64,f_Mat_channels :: Maybe Int64,f_Mat_type :: Maybe Int64,f_Mat_data :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable Mat where
  hashWithSalt salt record = salt   `hashWithSalt` f_Mat_rows record   `hashWithSalt` f_Mat_cols record   `hashWithSalt` f_Mat_channels record   `hashWithSalt` f_Mat_type record   `hashWithSalt` f_Mat_data record  
write_Mat oprot record = do
  writeStructBegin oprot "Mat"
  case f_Mat_data record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("data",T_STRING,-5)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Mat_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_I64,-4)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Mat_channels record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("channels",T_I64,-3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Mat_cols record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cols",T_I64,-2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Mat_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_I64,-1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Mat_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      -1 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_rows=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -2 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_cols=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -3 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_channels=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -4 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_type=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -5 -> if _t3 == T_STRING then do
        s <- readBinary iprot
        read_Mat_fields iprot record{f_Mat_data=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Mat_fields iprot record
read_Mat iprot = do
  _ <- readStructBegin iprot
  record <- read_Mat_fields iprot (Mat{f_Mat_rows=Nothing,f_Mat_cols=Nothing,f_Mat_channels=Nothing,f_Mat_type=Nothing,f_Mat_data=Nothing})
  readStructEnd iprot
  return record
data MatUnpacked = MatUnpacked{f_MatUnpacked_rows :: Maybe Int64,f_MatUnpacked_cols :: Maybe Int64,f_MatUnpacked_channels :: Maybe Int64,f_MatUnpacked_data :: Maybe (Vector.Vector Double)} deriving (Show,Eq,Typeable)
instance Hashable MatUnpacked where
  hashWithSalt salt record = salt   `hashWithSalt` f_MatUnpacked_rows record   `hashWithSalt` f_MatUnpacked_cols record   `hashWithSalt` f_MatUnpacked_channels record   `hashWithSalt` f_MatUnpacked_data record  
write_MatUnpacked oprot record = do
  writeStructBegin oprot "MatUnpacked"
  case f_MatUnpacked_data record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("data",T_LIST,-4)
    (let f = Vector.mapM_ (\_viter7 -> writeDouble oprot _viter7) in do {writeListBegin oprot (T_DOUBLE,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_MatUnpacked_channels record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("channels",T_I64,-3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_MatUnpacked_cols record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cols",T_I64,-2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_MatUnpacked_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_I64,-1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MatUnpacked_fields iprot record = do
  (_,_t9,_id10) <- readFieldBegin iprot
  if _t9 == T_STOP then return record else
    case _id10 of 
      -1 -> if _t9 == T_I64 then do
        s <- readI64 iprot
        read_MatUnpacked_fields iprot record{f_MatUnpacked_rows=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      -2 -> if _t9 == T_I64 then do
        s <- readI64 iprot
        read_MatUnpacked_fields iprot record{f_MatUnpacked_cols=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      -3 -> if _t9 == T_I64 then do
        s <- readI64 iprot
        read_MatUnpacked_fields iprot record{f_MatUnpacked_channels=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      -4 -> if _t9 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readDouble iprot) in do {(_etype14,_size11) <- readListBegin iprot; f _size11})
        read_MatUnpacked_fields iprot record{f_MatUnpacked_data=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      _ -> do
        skip iprot _t9
        readFieldEnd iprot
        read_MatUnpacked_fields iprot record
read_MatUnpacked iprot = do
  _ <- readStructBegin iprot
  record <- read_MatUnpacked_fields iprot (MatUnpacked{f_MatUnpacked_rows=Nothing,f_MatUnpacked_cols=Nothing,f_MatUnpacked_channels=Nothing,f_MatUnpacked_data=Nothing})
  readStructEnd iprot
  return record
