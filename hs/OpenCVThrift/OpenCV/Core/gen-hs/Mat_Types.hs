{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Mat_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()

import qualified CVDef_Types


data Mat = Mat{f_Mat_rows :: Maybe Int64,f_Mat_cols :: Maybe Int64,f_Mat_channels :: Maybe Int64,f_Mat_type :: Maybe CVType,f_Mat_data :: Maybe ByteString} deriving (Show,Eq,Typeable)
instance Hashable Mat where
  hashWithSalt salt record = salt   `hashWithSalt` f_Mat_rows record   `hashWithSalt` f_Mat_cols record   `hashWithSalt` f_Mat_channels record   `hashWithSalt` f_Mat_type record   `hashWithSalt` f_Mat_data record  
write_Mat oprot record = do
  writeStructBegin oprot "Mat"
  case f_Mat_data record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("data",T_STRING,-5)
    writeBinary oprot _v
    writeFieldEnd oprot}
  case f_Mat_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_I32,-4)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Mat_channels record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("channels",T_I64,-3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Mat_cols record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cols",T_I64,-2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_Mat_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_I64,-1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Mat_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      -1 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_rows=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -2 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_cols=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -3 -> if _t3 == T_I64 then do
        s <- readI64 iprot
        read_Mat_fields iprot record{f_Mat_channels=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -4 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Mat_fields iprot record{f_Mat_type=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      -5 -> if _t3 == T_STRING then do
        s <- readBinary iprot
        read_Mat_fields iprot record{f_Mat_data=Just s}
        else do
          skip iprot _t3
          read_Mat_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Mat_fields iprot record
read_Mat iprot = do
  _ <- readStructBegin iprot
  record <- read_Mat_fields iprot (Mat{f_Mat_rows=Nothing,f_Mat_cols=Nothing,f_Mat_channels=Nothing,f_Mat_type=Nothing,f_Mat_data=Nothing})
  readStructEnd iprot
  return record
data MatUnpacked = MatUnpacked{f_MatUnpacked_rows :: Maybe Int64,f_MatUnpacked_cols :: Maybe Int64,f_MatUnpacked_channels :: Maybe Int64,f_MatUnpacked_data :: Maybe (Vector.Vector Double)} deriving (Show,Eq,Typeable)
instance Hashable MatUnpacked where
  hashWithSalt salt record = salt   `hashWithSalt` f_MatUnpacked_rows record   `hashWithSalt` f_MatUnpacked_cols record   `hashWithSalt` f_MatUnpacked_channels record   `hashWithSalt` f_MatUnpacked_data record  
write_MatUnpacked oprot record = do
  writeStructBegin oprot "MatUnpacked"
  case f_MatUnpacked_data record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("data",T_LIST,-4)
    (let f = Vector.mapM_ (\_viter7 -> writeDouble oprot _viter7) in do {writeListBegin oprot (T_DOUBLE,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_MatUnpacked_channels record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("channels",T_I64,-3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_MatUnpacked_cols record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("cols",T_I64,-2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_MatUnpacked_rows record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rows",T_I64,-1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_MatUnpacked_fields iprot record = do
  (_,_t9,_id10) <- readFieldBegin iprot
  if _t9 == T_STOP then return record else
    case _id10 of 
      -1 -> if _t9 == T_I64 then do
        s <- readI64 iprot
        read_MatUnpacked_fields iprot record{f_MatUnpacked_rows=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      -2 -> if _t9 == T_I64 then do
        s <- readI64 iprot
        read_MatUnpacked_fields iprot record{f_MatUnpacked_cols=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      -3 -> if _t9 == T_I64 then do
        s <- readI64 iprot
        read_MatUnpacked_fields iprot record{f_MatUnpacked_channels=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      -4 -> if _t9 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readDouble iprot) in do {(_etype14,_size11) <- readListBegin iprot; f _size11})
        read_MatUnpacked_fields iprot record{f_MatUnpacked_data=Just s}
        else do
          skip iprot _t9
          read_MatUnpacked_fields iprot record
      _ -> do
        skip iprot _t9
        readFieldEnd iprot
        read_MatUnpacked_fields iprot record
read_MatUnpacked iprot = do
  _ <- readStructBegin iprot
  record <- read_MatUnpacked_fields iprot (MatUnpacked{f_MatUnpacked_rows=Nothing,f_MatUnpacked_cols=Nothing,f_MatUnpacked_channels=Nothing,f_MatUnpacked_data=Nothing})
  readStructEnd iprot
  return record
