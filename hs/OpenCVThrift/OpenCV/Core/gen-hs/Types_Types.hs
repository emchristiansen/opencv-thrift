{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (1.0.0-dev)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Types_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


data Point2d = Point2d{f_Point2d_x :: Maybe Double,f_Point2d_y :: Maybe Double} deriving (Show,Eq,Typeable)
instance Hashable Point2d where
  hashWithSalt salt record = salt   `hashWithSalt` f_Point2d_x record   `hashWithSalt` f_Point2d_y record  
write_Point2d oprot record = do
  writeStructBegin oprot "Point2d"
  case f_Point2d_y record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("y",T_DOUBLE,-2)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_Point2d_x record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("x",T_DOUBLE,-1)
    writeDouble oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Point2d_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      -1 -> if _t3 == T_DOUBLE then do
        s <- readDouble iprot
        read_Point2d_fields iprot record{f_Point2d_x=Just s}
        else do
          skip iprot _t3
          read_Point2d_fields iprot record
      -2 -> if _t3 == T_DOUBLE then do
        s <- readDouble iprot
        read_Point2d_fields iprot record{f_Point2d_y=Just s}
        else do
          skip iprot _t3
          read_Point2d_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Point2d_fields iprot record
read_Point2d iprot = do
  _ <- readStructBegin iprot
  record <- read_Point2d_fields iprot (Point2d{f_Point2d_x=Nothing,f_Point2d_y=Nothing})
  readStructEnd iprot
  return record
data KeyPoint = KeyPoint{f_KeyPoint_pt :: Maybe Point2d,f_KeyPoint_size :: Maybe Double,f_KeyPoint_angle :: Maybe Double,f_KeyPoint_response :: Maybe Double,f_KeyPoint_octave :: Maybe Int64,f_KeyPoint_class_id :: Maybe Int64} deriving (Show,Eq,Typeable)
instance Hashable KeyPoint where
  hashWithSalt salt record = salt   `hashWithSalt` f_KeyPoint_pt record   `hashWithSalt` f_KeyPoint_size record   `hashWithSalt` f_KeyPoint_angle record   `hashWithSalt` f_KeyPoint_response record   `hashWithSalt` f_KeyPoint_octave record   `hashWithSalt` f_KeyPoint_class_id record  
write_KeyPoint oprot record = do
  writeStructBegin oprot "KeyPoint"
  case f_KeyPoint_class_id record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("class_id",T_I64,-6)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_KeyPoint_octave record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("octave",T_I64,-5)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_KeyPoint_response record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("response",T_DOUBLE,-4)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_KeyPoint_angle record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("angle",T_DOUBLE,-3)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_KeyPoint_size record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("size",T_DOUBLE,-2)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_KeyPoint_pt record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("pt",T_STRUCT,-1)
    write_Point2d oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_KeyPoint_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      -1 -> if _t8 == T_STRUCT then do
        s <- (read_Point2d iprot)
        read_KeyPoint_fields iprot record{f_KeyPoint_pt=Just s}
        else do
          skip iprot _t8
          read_KeyPoint_fields iprot record
      -2 -> if _t8 == T_DOUBLE then do
        s <- readDouble iprot
        read_KeyPoint_fields iprot record{f_KeyPoint_size=Just s}
        else do
          skip iprot _t8
          read_KeyPoint_fields iprot record
      -3 -> if _t8 == T_DOUBLE then do
        s <- readDouble iprot
        read_KeyPoint_fields iprot record{f_KeyPoint_angle=Just s}
        else do
          skip iprot _t8
          read_KeyPoint_fields iprot record
      -4 -> if _t8 == T_DOUBLE then do
        s <- readDouble iprot
        read_KeyPoint_fields iprot record{f_KeyPoint_response=Just s}
        else do
          skip iprot _t8
          read_KeyPoint_fields iprot record
      -5 -> if _t8 == T_I64 then do
        s <- readI64 iprot
        read_KeyPoint_fields iprot record{f_KeyPoint_octave=Just s}
        else do
          skip iprot _t8
          read_KeyPoint_fields iprot record
      -6 -> if _t8 == T_I64 then do
        s <- readI64 iprot
        read_KeyPoint_fields iprot record{f_KeyPoint_class_id=Just s}
        else do
          skip iprot _t8
          read_KeyPoint_fields iprot record
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_KeyPoint_fields iprot record
read_KeyPoint iprot = do
  _ <- readStructBegin iprot
  record <- read_KeyPoint_fields iprot (KeyPoint{f_KeyPoint_pt=Nothing,f_KeyPoint_size=Nothing,f_KeyPoint_angle=Nothing,f_KeyPoint_response=Nothing,f_KeyPoint_octave=Nothing,f_KeyPoint_class_id=Nothing})
  readStructEnd iprot
  return record
data DMatch = DMatch{f_DMatch_queryIndex :: Maybe Int64,f_DMatch_trainIndex :: Maybe Int64,f_DMatch_imageIndex :: Maybe Int64,f_DMatch_distance :: Maybe Double} deriving (Show,Eq,Typeable)
instance Hashable DMatch where
  hashWithSalt salt record = salt   `hashWithSalt` f_DMatch_queryIndex record   `hashWithSalt` f_DMatch_trainIndex record   `hashWithSalt` f_DMatch_imageIndex record   `hashWithSalt` f_DMatch_distance record  
write_DMatch oprot record = do
  writeStructBegin oprot "DMatch"
  case f_DMatch_distance record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("distance",T_DOUBLE,-4)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_DMatch_imageIndex record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("imageIndex",T_I64,-3)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_DMatch_trainIndex record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("trainIndex",T_I64,-2)
    writeI64 oprot _v
    writeFieldEnd oprot}
  case f_DMatch_queryIndex record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("queryIndex",T_I64,-1)
    writeI64 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DMatch_fields iprot record = do
  (_,_t13,_id14) <- readFieldBegin iprot
  if _t13 == T_STOP then return record else
    case _id14 of 
      -1 -> if _t13 == T_I64 then do
        s <- readI64 iprot
        read_DMatch_fields iprot record{f_DMatch_queryIndex=Just s}
        else do
          skip iprot _t13
          read_DMatch_fields iprot record
      -2 -> if _t13 == T_I64 then do
        s <- readI64 iprot
        read_DMatch_fields iprot record{f_DMatch_trainIndex=Just s}
        else do
          skip iprot _t13
          read_DMatch_fields iprot record
      -3 -> if _t13 == T_I64 then do
        s <- readI64 iprot
        read_DMatch_fields iprot record{f_DMatch_imageIndex=Just s}
        else do
          skip iprot _t13
          read_DMatch_fields iprot record
      -4 -> if _t13 == T_DOUBLE then do
        s <- readDouble iprot
        read_DMatch_fields iprot record{f_DMatch_distance=Just s}
        else do
          skip iprot _t13
          read_DMatch_fields iprot record
      _ -> do
        skip iprot _t13
        readFieldEnd iprot
        read_DMatch_fields iprot record
read_DMatch iprot = do
  _ <- readStructBegin iprot
  record <- read_DMatch_fields iprot (DMatch{f_DMatch_queryIndex=Nothing,f_DMatch_trainIndex=Nothing,f_DMatch_imageIndex=Nothing,f_DMatch_distance=Nothing})
  readStructEnd iprot
  return record
